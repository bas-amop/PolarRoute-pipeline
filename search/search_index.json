{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"PolarRoute-pipeline","text":"<p>PolarRoute-pipeline is a data pipeline used to automate the generation of ocean/sea-ice meshes (and optionally optimised routes) for ocean vessel route-planning. This data pipeline is one component of the British Antarctic Survey's Operational PolarRoute (OPR) project.</p>"},{"location":"#using-this-documentation","title":"Using this documentation","text":"<p>Most of these docs are primarily aimed at developers of PolarRoute-pipeline or administrators who want to install and run a copy of the pipeline.</p>"},{"location":"about/","title":"About","text":"<p>PolarRoute-pipeline is a data pipeline used to automate the generation of ocean/sea-ice meshes (and optionally optimised routes) for ocean vessel route-planning. This data pipeline is one component of the British Antarctic Survey's Operational PolarRoute (OPR) project.</p>"},{"location":"development/","title":"Development","text":"<p>Depends on:</p> <ul> <li>Python &gt;=3.9</li> </ul> <ol> <li>Clone the repository and create and activate a python virtual environment of your choice.</li> <li>Inside a virtual environment or machine: <code>python -m pip install -r requirements.txt</code></li> </ol>"},{"location":"development/#releaseversioning","title":"Release/Versioning","text":"<p>Version numbers should be used in tagging commits on the <code>main</code> branch and should be of the form <code>v0.1.7</code> using the semantic versioning convention.</p>"},{"location":"development/#building-deploying-the-documentation","title":"Building &amp; deploying the documentation","text":"<p>The documentation should build automatically on pushes to <code>main</code> using GitHub actions, if you want to build and deploy the docs manually, follow these steps:</p> <ul> <li>Run <code>make build-docs</code> to build the docs to the <code>./site</code> directory.</li> <li>Then run <code>make deploy-docs</code> to deploy to the <code>gh-pages</code> branch of the repository. You must have write access to the repo.</li> </ul>"},{"location":"how-polarroute-pipeline-works/","title":"How PolarRoute-pipeline works","text":"<p>PolarRoute-pipeline creates one or more meshes using up-to-date source datasets. These meshes can then have optimised routes calculated upon them with optimisations such as fuel or traveltime.  </p> <p>The logical flow of the pipeline is built from the application.yaml config file, which details what tasks are to be performed and their dependencies. The pipeline resolves these dependencies and allows tasks to run in parallel, depending how many <code>WORKERS</code> have been defined in the pipeline.yaml.  </p> <p>If any task fails to complete successfully, it will raise an exception and prevent any future dependencies from executing.</p>"},{"location":"how-polarroute-pipeline-works/#the-workflow-manager","title":"The workflow manager","text":"<p>The pipeline build command creates or re-creates from the <code>application.yaml</code> and <code>pipeline.yaml</code> a python script that is used by the Jug parallelisation package. The pipeline invokes 'Jug' with this python script for each <code>WORKER</code>, creating one or more parallel processes that can complete multiple tasks which being monitored. This collection of python script, 'Jug' and <code>WORKERS</code> is referred to as the 'workflow-manager'.  </p> <p>Everything related to the workflow manager's operation is contained within the <code>&lt;pipeline&gt;/workflow-manager/</code> directory, which is created by the 'build' command.</p>"},{"location":"how-polarroute-pipeline-works/#pipelineyaml","title":"<code>pipeline.yaml</code>","text":"<p>This configuration file can be mostly left untouched other than the <code>MAXWORKERS</code> definition. The workflow manager will attempt to allocate up to this many workers to the pipeline.  </p> <p>Example: | You have 10 tasks the could all execute in parallel. | You are using a platform that has 6 CPU threads.   * If you set <code>MAXWORKERS</code> to <code>2</code> the workflow manager will invoke 2 workers, meaning that the 2 CPU threads can complete all 10 tasks twice as quickly as if there was only 1 worker (i.e. 1 task done at a time).   * If you set <code>MAXWORKERS</code> to <code>10</code> the workflow manager will invoke 10 workers but because this is more than available CPU threads there will be a significant amount of CPU context switching to achieve the effect of 10 CPU threads running. This results in slower performance.   * If you set <code>MAXWORKERS</code> to <code>5</code> the workflow manager will invoke 5 workers, meaning that the 5 CPU threads can complete all 10 tasks five times as quickly as if there was only 1 worker (i.e. 1 task done at a time). This would also avoid CPU context switch and also leave 1 CPU thread free for the underlying platform.  </p>"},{"location":"how-polarroute-pipeline-works/#applicationyaml","title":"<code>application.yaml</code>","text":""},{"location":"how-polarroute-pipeline-works/#environment-variables","title":"Environment variables","text":"<p>If the pipeline relies upon constants held within environment variables, these can be pre-defined under the <code>env:variables:</code> section of the yaml config file.  </p> <p>Also note that the <code>PIPELINE_DIRECTORY</code> and <code>SCRIPTS_DIRECTORY</code> are mandatory for the pipeline to know where it is and where to look for the task scripts.  </p>"},{"location":"how-polarroute-pipeline-works/#task-sequence","title":"Task sequence","text":"<p>The sequence order and dependancies of the tasks (scripts) are defined under the <code>sequence:</code> section of the yaml config file.  </p> <p>Each task (script) in the sequence has a <code>name:</code> and <code>depends:</code> field. The name is the name of the script to be found in the scripts directory. The depends can be either a single script name or a list of script names if there are multiple dependancies. If a script has no dependancy then the <code>depends:</code> field should contain an empty string <code>''</code>.  </p> <p>Currently shell scripts <code>.sh</code> and python scripts <code>.py</code> are the only supported task (script) names. </p> <p>Inspect the application.yaml to show how the sequence of tasks can be constructed.  </p>"},{"location":"how-polarroute-pipeline-works/#logs","title":"Logs","text":"<p>Logs of stderr and stdout are stored in <code>&lt;pipeline&gt;/logs/&lt;config_name&gt;_&lt;date&gt;.err</code> and <code>&lt;pipeline&gt;/logs/&lt;config_name&gt;_&lt;date&gt;.out</code> for debugging purposes.  </p>"},{"location":"how-polarroute-pipeline-works/#further-detail","title":"Further detail","text":"<p>For more detail on the inner workings of the tasks PolarRoute-pipeline performs, please refer to the documentation for:  - Jug  - PolarRoute  - MeshiPhi </p>"},{"location":"implementation/","title":"Implementation","text":"<p>PolarRoute-pipeline is one of three broadly distinct components of the Operational PolarRoute (OPR) project.</p> <ol> <li> <p>PolarRoute-pipeline (this repo) Required data products are downloaded, stored and processed shoreside where the data and compute resources are abundant. This generates ocean/sea-ice meshes (and routes if required) for areas of operational interest. These generated outputs are compressed and transferred via satellite (or other) link to shipside. PolarRoute-pipeline is built on the technologies of PolarRoute and MeshiPhi.</p> </li> <li> <p>PolarRoute-server Once the meshes are available shipside they are ingested into an onboard database which allows them to be used to calculate optimised travel routes. These are calculated on demand and presented to the onboard user digitally. PolarRoute-server handles the onboard mesh ingestion and route calculation through a command-line or graphical user interface.</p> </li> <li> <p>Sea-Ice-Information-System (SIIS) The SIIS front-end provides a graphical user interface whereby users can interact with Operational PolarRoute through a standard web browser.</p> </li> </ol> <p>From the three distinct components defined above, this documentation is concerned only with part (1.)  </p>"},{"location":"implementation/#basic-process-flow-diagram","title":"Basic process flow diagram","text":""},{"location":"implementation/#detailed-process-flow-diagram","title":"Detailed process flow diagram","text":""},{"location":"implementation/#history","title":"History","text":"<p>During 2024 the previous repository was manually ported from a hierarchy of bash and python scripts to an implementation using a workflow manager. The original scripts remained mostly unchanged although the introduction of the Jug parallelisation package allowed the scripts to execute with strict dependency, monitoring and pipeline control. This was initially achieved using a handbuilt workflow manager script <code>operational-polarroute.py</code>.  </p>"},{"location":"implementation/#september-2024-onwards","title":"September 2024 onwards","text":"<p>The workflow manager concept was rebuilt as a separate and generic workflow manager forming the package simple-action-pipeline. PolarRoute-pipeline was then ported to being a configuration of simple-action-pipeline.</p>"},{"location":"installation/","title":"Installing the pipeline","text":"<p>It is recommended to use a Python virtual environment to reduce the risk of any Python package conflicts.</p>"},{"location":"installation/#hpc-workstation-or-local-pc","title":"HPC Workstation or Local PC","text":"<ol> <li> <p>Create a Python virtual environment    The Python version must be Python 3.9 or higher (3.12 was used during development).</p> <ul> <li>Check the available Python with <code>python --version</code></li> <li>If required, install or load a compatible python version. Your HPC administrator will be able to help with getting a compatible Python version.</li> <li>then <code>python -m venv &lt;path-to-venv&gt;</code> with a path of your choosing.</li> </ul> </li> <li> <p>Source the new newly created python venv </p> <ul> <li><code>source &lt;path-to-venv&gt;/bin/activate</code> (Assuming you're using Bash or similar. Use the appropriate activate script within that folder depending on your shell)</li> </ul> </li> <li> <p>Clone this repository</p> <ul> <li>Assuming you have already cloned this repository into a directory, move into the 'root' of this repository. <code>cd polarroute-pipeline</code>.</li> <li>Otherwise <code>git clone https://github.com/bas-amop/PolarRoute-pipeline.git polarroute-pipeline</code></li> <li>then <code>cd polarroute-pipeline</code></li> </ul> </li> <li> <p>Install requirements </p> <ul> <li>Using python pip (inside the created venv) <code>python -m pip install -r requirements.txt</code></li> </ul> </li> </ol>"},{"location":"setting-up/","title":"Setting up the pipeline","text":"<p>Even before the pipeline can be built for the first time, there are a number of one-time setup steps required.</p> <ol> <li> <p>Assuming you have already created a Python virtual environment and cloned this repository into a directory on a HPC Workstation or Local PC, move into the 'root' of the repository. <code>cd polarroute-pipeline</code> </p> </li> <li> <p>Create symbolic links for the venv activation script, datastore (where downloaded data products are to be stored), logs,  outputs (where the generated outputs are to be stored), html (for the summary status page) and upload + push (where outputs are copied to be sent shipside).</p> <ul> <li><code>ln -s &lt;path-to-venv&gt;/bin/activate &lt;path-to-this-repo&gt;/activate</code></li> <li><code>ln -s &lt;path-to-datastore&gt; &lt;path-to-this-repo&gt;/datastore</code></li> <li><code>ln -s &lt;path-to-logs-directory&gt; &lt;path-to-this-repo&gt;/logs</code></li> <li><code>ln -s &lt;path-to-output-archive&gt; &lt;path-to-this-repo&gt;/outputs</code></li> <li><code>ln -s &lt;path-to-upload-directory&gt; &lt;path-to-this-repo&gt;/upload</code></li> <li><code>ln -s &lt;path-to-push-directory&gt; &lt;path-to-this-repo&gt;/push</code></li> <li><code>ln -s &lt;path-to-html-directory&gt; &lt;path-to-this-repo&gt;/html</code> </li> </ul> </li> </ol> <p>The links created above are specific to PolarRoute-pipeline as various data products are stored in differen't remote or local directories. If you are setting up a completely local instance of PolarRoute-pipeline then you could just create local folders within the pipeline directory, instead of links to external locations. Below is an explanation of why each link/directory is required:  </p> Directory or Link Purpose <code>&lt;pipeline&gt;/activate</code> So the pipeline knows which activation script to use <code>&lt;pipeline&gt;/datastore</code> Where to store and retrieve downloaded source datasets <code>&lt;pipeline&gt;/logs</code> Where to keep any log files <code>&lt;pipeline&gt;/outputs</code> Where to store and retrieve daily pipeline output products <code>&lt;pipeline&gt;/upload</code> Where to 'prepare' specific outputs before being sent <code>&lt;pipeline&gt;/push</code> Where to place any outputs to be sent. Specifically, the pipeline copies output products from the <code>upload</code> directory into the <code>push</code> directory. These are then picked up by an external synchronisation system which 'pulls' the products and automatically removes them from the <code>push</code> directory afterwards <code>&lt;pipeline&gt;/html</code> Where the pipeline publishes a static html summary page"},{"location":"setting-up/#setting-up-download-credentials","title":"Setting up download credentials","text":"<p>PolarRoute-pipeline will need to use valid credentials to download ERA5 and DUACS products, ensure you have these set up as detailed below:</p>"},{"location":"setting-up/#era5","title":"ERA5","text":"<p>The ERA5 downloader scripts make use of the CDS API (via the cdsapi python package) and require you to create a .cdsapirc file in your home directory ($HOME/.cdsapirc) containing a valid url and key for the API as described here: https://cds.climate.copernicus.eu/api-how-to  </p> <p>From a shell:</p> <pre><code>echo url: https://cds-beta.climate.copernicus.eu/api &gt; $HOME/.cdsapirc\necho key: &lt;your-unique-api-key&gt; &gt;&gt; $HOME/.cdsapirc\necho verify:0 &gt;&gt; $HOME/.cdsapirc\n</code></pre>"},{"location":"setting-up/#copernicus-marine-api","title":"Copernicus Marine API","text":"<p>The Copernicus API to is used to download up-to-date DUACS currents data. This service requires obtaining a USERNAME and PASSWORD for logging in. Once you have the username and password they can be stored separately to the pipeline in the user's <code>HOME</code> directory. You can register on the Copernicus Marine API Registration page. Then, use the <code>copernicusmarine</code> command line tool to log in and set up your credentials file. First make sure that your python virtual environment is activated and you have installed the dependencies. Then:</p> <pre><code>copernicusmarine login\n# you will be prompted for your username and password and your credentials will be stored in a file at $HOME/.copernicusmarine/.copernicusmarine-credentials\n</code></pre> <p>Alternativey, Copernicus Marine credentials can be set using environment variables <code>COPERNICUSMARINE_SERVICE_USERNAME</code> and <code>COPERNICUSMARINE_SERVICE_PASSWORD</code> - these will be used in preference to the credentials file.</p> <p>Now that everything is set up, the PolarRoute-pipeline can be used. Please refer to the Using the pipeline section of this documentation for details of how to operate the pipeline.</p>"},{"location":"setting-up/#gebco-bathymetry-data","title":"GEBCO Bathymetry data","text":"<p>If you are running the pipeline locally, and do not have access to the BAS  infrastructure (specifically the SAN), you can use the following script to download and set up the GEBCO gridded bathymetry data:</p> <pre><code>mkdir -p datastore/bathymetry/gebco &amp;&amp; cd $_\n\n# Make a request using wget - this can take a while to download\n# as this bathymetry model can be greater than 7GB in size.\n# Take note of the year here, newer versions may be available\nwget -O gebco.zip https://www.bodc.ac.uk/data/open_download/gebco/gebco_2024/zip/\n\nunzip gebco.zip\nmv GEBCO_2024.nc gebco_global.nc\n\n# Clean up, remove any unnecessary files\nrm gebco.zip\nrm *.pdf\n</code></pre> <p>This is a large and static dataset, therefore you should only need to run this once.</p>"},{"location":"using/","title":"Using the pipeline","text":"<p>If using a freshly installed pipeline for the first time, then the pipeline must be built from the provided pipeline and application yaml files. This also applies if changes have been made to either yaml file, i.e. the pipeline <code>build</code> command must be issued for any yaml configuration changes to take effect.</p> <ul> <li>make sure your virtual environment is activated before issuing any of the commands below <code>source &lt;path-to-this-pipeline-directory&gt;\\activate</code> </li> </ul>"},{"location":"using/#build-the-pipeline-build","title":"Build the pipeline <code>build</code>","text":"<p>To build the pipeline from the provided <code>pipeline.yaml</code> and <code>application.yaml</code>, run the command:  </p> <pre><code>pipeline build &lt;path-to-this-pipeline-directory&gt;\n</code></pre>"},{"location":"using/#get-the-pipeline-status-status","title":"Get the pipeline status <code>status</code>","text":"<p>As well as checking the status, it can also be used to check that the pipeline is installed and setup correctly. This can be done by running the pipeline's <code>status</code> command:</p> <pre><code>pipeline status &lt;path-to-this-pipeline-directory&gt;\n# or for the short output\npipeline status &lt;path-to-this-pipeline-directory&gt; --short\n</code></pre> <p>A long (or short) report should be output. This <code>status</code> command can be run at any time and will give the 'live' state of the pipeline and it's tasks.</p> <ul> <li>The status of the pipeline is stateful and persistent, even after the execution is completed, which is useful for querying long after the pipeline has completed. This holds true if the pipeline fails for any reason.  </li> </ul>"},{"location":"using/#execute-the-pipeline-execute","title":"Execute the pipeline <code>execute</code>","text":"<p>To start the pipeline, run the command:</p> <pre><code>pipeline execute &lt;path-to-this-pipeline-directory&gt;\n</code></pre>"},{"location":"using/#reset-the-pipeline-reset","title":"Reset the pipeline <code>reset</code>","text":"<p>Because the statefulness of the pipeline persists even after completion, an additional step is required before the pipeline can be executed again. This is called a <code>reset</code>, and when initiated, the workflow manager erases the state of the pipeline ready for re-execution.  </p> <p>A reset can be performed by running the command:</p> <pre><code>pipeline reset &lt;path-to-this-pipeline-directory&gt;\n</code></pre> <ul> <li>Resetting a running pipeline is not advised and may produce unpredictable behaviour (please refer to <code>halt</code> below).  </li> </ul>"},{"location":"using/#halt-all-pipeline-tasks-halt","title":"Halt all pipeline tasks <code>halt</code>","text":"<p>If the pipeline needs to be halted whilst it is running, the <code>halt</code> command has been provided.  </p> <pre><code>pipeline halt &lt;path-to-this-pipeline-directory&gt;\n</code></pre> <ul> <li>This does not erase the statefulness of the pipeline, so the <code>status</code> command can be used after halting has occured. Any pipeline tasks that have already completed will remain so, although any tasks which haven't fully completed will revert to being not started.  </li> </ul> <p>Following a 'halt' there are two possible choices:  </p> <ol> <li><code>execute</code> will resume the pipeline from where it was halted.</li> <li><code>reset</code> will reset the pipeline to it's un-executed state.</li> </ol>"},{"location":"using/#tips","title":"Tips","text":"<ul> <li> <p>Using any of the pipeline commands does not require sourcing of the pipeline's <code>pipeline.env</code> and <code>application.env</code> files beforehand, this is automatically handled by the pipeline.  </p> </li> <li> <p>Running the pipeline command from inside a pipeline directory does not require specifying the <code>&lt;path-to-pipeline-directory&gt;</code> argument. When this argument is missing, the pipeline assumes the use of the current working directory. For instance, if you are inside the pipeline directory, you can simply issue the command <code>pipeline status</code> to get the current status.</p> </li> </ul>"}]}